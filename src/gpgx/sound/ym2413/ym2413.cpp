/**
 * File: ym2413.c - software implementation of YM2413
 *                  FM sound generator type OPLL
 *
 * Copyright (C) 2002 Jarek Burczynski
 *
 * Version 1.0
 * 
 * To do:
 * - make sure of the sinus amplitude bits
 * - make sure of the EG resolution bits (looks like the biggest
 *   modulation index generated by the modulator is 123, 124 = no modulation)
 * - find proper algorithm for attack phase of EG
 * - tune up instruments ROM
 * - support sample replay in test mode (it is NOT as simple as setting bit 0
 *   in register 0x0f and using register 0x10 for sample data).
 *   Which games use this feature ?
 *
 * Modifications for Genesis Plus GX (EkeEke):
 * - 2011/xx/xx: removed multiple chips support, cleaned code & added FM board interface
 * - 2021/04/23: fixed synchronization of carrier/modulator phase reset after channel Key ON (fixes Japanese Master System BIOS music)
 * - 2021/04/24: fixed intruments ROM (verified on YM2413B die, cf. https://siliconpr0n.org/archive/doku.php?id=vendor:yamaha:opl2#ym2413_instrument_rom)
 * - 2021/04/24: fixed EG resolution bits (verified on YM2413B die, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2015-03-20)
 * - 2021/04/24: fixed EG dump rate (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2015-12-31)
 * - 2021/04/25: fixed EG behavior for fastest attack rates (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
 * - 2021/04/25: fixed EG behavior when SL = 0 (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2015-12-24)
 * - 2021/04/25: improved EG sustain phase transition comparator accuracy (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2015-12-31)
 * - 2021/05/04: improved EG increment steps accuracy (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2015-03-20)
 * - 2021/05/08: improved EG transitions accuracy (verified against https://github.com/nukeykt/Nuked-OPLL/blob/master/opll.c)
 * - 2021/05/11: improved EG attack phase algorithm accuracy (verified on YM2413 real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
 * - 2022/08/07: fixed operator ouput when EG is off
 */

#include "gpgx/sound/ym2413/ym2413.h"

#include <cmath>

#include "core/macros.h"
#include "core/state.h"

#include "xee/fnd/data_type.h"
#include "xee/mem/memory.h"

#include "gpgx/sound/ym2413/opll_slot.h"
#include "gpgx/sound/ym2413/opll_ch.h"

namespace gpgx::sound::ym2413 {

//==============================================================================
// Ym2413

//------------------------------------------------------------------------------


#define FREQ_SH 16  // 16.16 fixed point (frequency calculations).
#define EG_SH   16  // 16.16 fixed point (EG timing).
#define LFO_SH  24  //  8.24 fixed point (LFO calculations).

#define FREQ_MASK    ((1 << FREQ_SH) - 1)

// envelope output entries.

#define ENV_BITS    10
#define ENV_LEN      (1 << ENV_BITS)
#define ENV_STEP    (128.0 / ENV_LEN)

#define MAX_ATT_INDEX  ((1 << (ENV_BITS - 3)) - 1) // 127
#define MIN_ATT_INDEX  (0)

// sinwave entries.

#define SIN_MASK    (kSinLen - 1)

// register number to channel number , slot offset.

#define SLOT1 0
#define SLOT2 1

// Envelope Generator phases.

#define EG_DMP      5
#define EG_ATT      4
#define EG_DEC      3
#define EG_SUS      2
#define EG_REL      1
#define EG_OFF      0

//------------------------------------------------------------------------------

#define DV (0.1875/1.0)

// Key scale level.
// table is 3dB/octave, DV converts this into 6dB/octave
// 0.1875 is bit 0 weight of the envelope counter (volume) expressed in the 'decibel' scale
const u32 Ym2413::kKeyScaleLevelTable[8*16]=
{
  // OCT 0
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
  // OCT 1
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 0.750/DV, 1.125/DV, 1.500/DV,
   1.875/DV, 2.250/DV, 2.625/DV, 3.000/DV,
  // OCT 2
   0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
   0.000/DV, 1.125/DV, 1.875/DV, 2.625/DV,
   3.000/DV, 3.750/DV, 4.125/DV, 4.500/DV,
   4.875/DV, 5.250/DV, 5.625/DV, 6.000/DV,
  // OCT 3
   0.000/DV, 0.000/DV, 0.000/DV, 1.875/DV,
   3.000/DV, 4.125/DV, 4.875/DV, 5.625/DV,
   6.000/DV, 6.750/DV, 7.125/DV, 7.500/DV,
   7.875/DV, 8.250/DV, 8.625/DV, 9.000/DV,
  // OCT 4
   0.000/DV, 0.000/DV, 3.000/DV, 4.875/DV,
   6.000/DV, 7.125/DV, 7.875/DV, 8.625/DV,
   9.000/DV, 9.750/DV,10.125/DV,10.500/DV,
  10.875/DV,11.250/DV,11.625/DV,12.000/DV,
  // OCT 5
   0.000/DV, 3.000/DV, 6.000/DV, 7.875/DV,
   9.000/DV,10.125/DV,10.875/DV,11.625/DV,
  12.000/DV,12.750/DV,13.125/DV,13.500/DV,
  13.875/DV,14.250/DV,14.625/DV,15.000/DV,
  // OCT 6
   0.000/DV, 6.000/DV, 9.000/DV,10.875/DV,
  12.000/DV,13.125/DV,13.875/DV,14.625/DV,
  15.000/DV,15.750/DV,16.125/DV,16.500/DV,
  16.875/DV,17.250/DV,17.625/DV,18.000/DV,
  // OCT 7
   0.000/DV, 9.000/DV,12.000/DV,13.875/DV,
  15.000/DV,16.125/DV,16.875/DV,17.625/DV,
  18.000/DV,18.750/DV,19.125/DV,19.500/DV,
  19.875/DV,20.250/DV,20.625/DV,21.000/DV
};

#undef DV

//------------------------------------------------------------------------------


#define SC(db) (u32) ( db * (1.0/ENV_STEP) )

// Sustain level table (3dB per step).
// 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,45 (dB)
const u32 Ym2413::kSustainLevelTable[16] = {
 SC(0),SC(1),SC(2),SC(3),SC(4),SC(5),SC(6),SC(7),
 SC(8),SC(9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(15)
};

#undef SC

//------------------------------------------------------------------------------


const unsigned char Ym2413::kEgInc[14 * kRateSteps] = {

  // cycle:0 1  2 3  4 5  6 7  8 9  10 11  12 13  14 15

  /* 0 */ 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, // infinity rates for decay(s)

  /* 1 */ 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, // rates 01..12 0 for decay(s) (increment by 0 or 1)
  /* 2 */ 0,1, 1,1, 0,1, 0,1, 0,1, 1,1, 0,1, 0,1, // rates 01..12 1 for decay(s)
  /* 3 */ 0,1, 1,1, 0,1, 1,1, 0,1, 1,1, 0,1, 1,1, // rates 01..12 2 for decay(s)
  /* 4 */ 0,1, 1,1, 1,1, 1,1, 0,1, 1,1, 1,1, 1,1, // rates 01..12 3 for decay(s)

  /* 5 */ 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, // rate 13 0 for decay(s) (increment by 0 or 1)
  /* 6 */ 0,1, 0,1, 1,1, 1,1, 0,1, 0,1, 0,1, 0,1, // rate 13 1 for decay(s)
  /* 7 */ 0,1, 0,1, 1,1, 1,1, 0,1, 0,1, 1,1, 1,1, // rate 13 2 for decay(s)
  /* 8 */ 0,1, 0,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, // rate 13 3 for decay(s)

  /* 9 */ 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, // rate 14 0 for decay(s) (increment by 1)
  /*10 */ 1,1, 1,1, 2,2, 2,2, 1,1, 1,1, 1,1, 1,1, // rate 14 1 for decay(s)
  /*11 */ 1,1, 1,1, 2,2, 2,2, 1,1, 1,1, 2,2, 2,2, // rate 14 2 for decay(s)
  /*12 */ 1,1, 1,1, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, // rate 14 3 for decay(s)

  /*13 */ 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, // rates 15 0, 15 1, 15 2, 15 3 for decay(s) (increment by 2)

};

const unsigned char Ym2413::kEgMul[17 * kRateSteps] = {

  // cycle:0 1  2 3  4 5  6 7  8 9  10 11  12 13  14 15

  /* 0 */ 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, // infinity rates for attack

  /* 1 */ 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, 0,1, // rates 01..11 0 for attack
  /* 2 */ 0,1, 1,1, 0,1, 0,1, 0,1, 1,1, 0,1, 0,1, // rates 01..11 1 for attack
  /* 3 */ 0,1, 1,1, 0,1, 1,1, 0,1, 1,1, 0,1, 1,1, // rates 01..11 2 for attack
  /* 4 */ 0,1, 1,1, 1,1, 1,1, 0,1, 1,1, 1,1, 1,1, // rates 01..11 3 for attack

  /* 5 */ 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, // rate 12 0 for attack
  /* 6 */ 1,1, 1,1, 2,2, 2,2, 1,1, 1,1, 1,1, 1,1, // rate 12 1 for attack
  /* 7 */ 1,1, 1,1, 2,2, 2,2, 1,1, 1,1, 2,2, 2,2, // rate 12 2 for attack
  /* 8 */ 1,1, 1,1, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, // rate 12 3 for attack

  /* 9 */ 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, 2,2, // rate 13 0 for attack
  /*10 */ 2,2, 2,2, 4,4, 4,4, 2,2, 2,2, 2,2, 2,2, // rate 13 1 for attack
  /*11 */ 2,2, 2,2, 4,4, 4,4, 2,2, 2,2, 4,4, 4,4, // rate 13 2 for attack
  /*12 */ 2,2, 2,2, 4,4, 4,4, 4,4, 4,4, 4,4, 4,4, // rate 13 3 for attack

  /*13 */ 4,4, 4,4, 4,4, 4,4, 4,4, 4,4, 4,4, 4,4, // rate 14 0 for attack
  /*14 */ 4,4, 4,4, 8,8, 8,8, 4,4, 4,4, 4,4, 4,4, // rate 14 1 for attack
  /*15 */ 4,4, 4,4, 8,8, 8,8, 4,4, 4,4, 8,8, 8,8, // rate 14 2 for attack
  /*16 */ 4,4, 4,4, 8,8, 8,8, 8,8, 8,8, 8,8, 8,8, // rate 14 3 for attack

};

//------------------------------------------------------------------------------

#define O(a) (a * kRateSteps)

// Envelope Generator rates (16 + 64 rates + 16 RKS).
const unsigned char Ym2413::kEgRateSelect[16 + 64 + 16] = {  

  // 16 infinite time rates
  O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
  O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),

  // rate 00
  O(0),O(0),O(0),O(0), // never used since infinite time rates are directly forced in the code for rate 00

  // rates 01-11
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),
  O(1),O(2),O(3),O(4),

  // rate 12, only used for decay(s), handled directly in the code for attack
  O(1),O(2),O(3),O(4),

  // rate 13, only used for decay(s), handled directly in the code for attack
  O(5),O(6),O(7),O(8),

  // rate 14, only used for decay(s), handled directly in the code for attack
  O(9),O(10),O(11),O(12),

  // rate 15, only used for decay(s), handled directly in the code for attack
  O(13),O(13),O(13),O(13),

  // 16 dummy rates (same as 15 3)
  O(13),O(13),O(13),O(13),O(13),O(13),O(13),O(13),
  O(13),O(13),O(13),O(13),O(13),O(13),O(13),O(13),

};

#undef O

//------------------------------------------------------------------------------

#define O(a) (a*1)

// rate  0,    1,    2,    3,    4,   5,   6,   7,  8,  9, 10, 11, 12, 13, 14, 15
// shift 13,   12,   11,   10,   9,   8,   7,   6,  5,  4,  3,  2,  1,  0,  0,  0
// mask  8191, 4095, 2047, 1023, 511, 255, 127, 63, 31, 15, 7,  3,  1,  0,  0,  0
// NB: for attack, above mask values lower 2 bits are cleared and rate 12 shift value is equal to 0.
// Envelope Generator counter shifts (16 + 64 rates + 16 RKS).
const unsigned char Ym2413::kEgRateShift[16 + 64 + 16] = {

  // 16 infinite time rates
  O(13),O(13),O(13),O(13),O(13),O(13),O(13),O(13),
  O(13),O(13),O(13),O(13),O(13),O(13),O(13),O(13),

  // rate 00
  O(13),O(13),O(13),O(13), // never used since infinite time rates are directly forced in the code for rate 00

  // rates 01-11
  O(12),O(12),O(12),O(12),
  O(11),O(11),O(11),O(11),
  O(10),O(10),O(10),O(10),
  O(9),O(9),O(9),O(9),
  O(8),O(8),O(8),O(8),
  O(7),O(7),O(7),O(7),
  O(6),O(6),O(6),O(6),
  O(5),O(5),O(5),O(5),
  O(4),O(4),O(4),O(4),
  O(3),O(3),O(3),O(3),
  O(2),O(2),O(2),O(2),

  // rate 12, only used for decay(s), handled directly in the code for attack
  O(1),O(1),O(1),O(1),

  // rate 13, only used for decay(s), handled directly in the code for attack
  O(0),O(0),O(0),O(0),

  // rate 14, only used for decay(s), handled directly in the code for attack
  O(0),O(0),O(0),O(0),

  // rate 15, only used for decay(s), handled directly in the code for attack
  O(0),O(0),O(0),O(0),

  // 16 dummy rates (same as 15 3)
  O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
  O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),

};

#undef O

//------------------------------------------------------------------------------

#define ML 2

// multiple table.
const u8 Ym2413::kMulTab[16]= {
  // 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,10,12,12,15,15
  0.50*ML, 1.00*ML, 2.00*ML, 3.00*ML, 4.00*ML, 5.00*ML, 6.00*ML, 7.00*ML,
  8.00*ML, 9.00*ML,10.00*ML,10.00*ML,12.00*ML,12.00*ML,15.00*ML,15.00*ML
};

#undef ML

//------------------------------------------------------------------------------

#define ENV_QUIET    (kTlTabLen >> 5)

//------------------------------------------------------------------------------

// LFO Amplitude Modulation table (verified on real YM3812)
// 27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples
// 
// Length: 210 elements.
// 
// Each of the elements has to be repeated
// exactly 64 times (on 64 consecutive samples).
// The whole table takes: 64 * 210 = 13440 samples.
// 
// We use data >> 1, until we find what it really is on real chip...
const u8 Ym2413::kLfoAmTable[kLfoAmTabElements] = {
0,0,0,0,0,0,0,
1,1,1,1,
2,2,2,2,
3,3,3,3,
4,4,4,4,
5,5,5,5,
6,6,6,6,
7,7,7,7,
8,8,8,8,
9,9,9,9,
10,10,10,10,
11,11,11,11,
12,12,12,12,
13,13,13,13,
14,14,14,14,
15,15,15,15,
16,16,16,16,
17,17,17,17,
18,18,18,18,
19,19,19,19,
20,20,20,20,
21,21,21,21,
22,22,22,22,
23,23,23,23,
24,24,24,24,
25,25,25,25,
26,26,26,
25,25,25,25,
24,24,24,24,
23,23,23,23,
22,22,22,22,
21,21,21,21,
20,20,20,20,
19,19,19,19,
18,18,18,18,
17,17,17,17,
16,16,16,16,
15,15,15,15,
14,14,14,14,
13,13,13,13,
12,12,12,12,
11,11,11,11,
10,10,10,10,
9,9,9,9,
8,8,8,8,
7,7,7,7,
6,6,6,6,
5,5,5,5,
4,4,4,4,
3,3,3,3,
2,2,2,2,
1,1,1,1
};

//------------------------------------------------------------------------------

// LFO Phase Modulation table (verified on real YM2413).
const s8 Ym2413::kLfoPmTable[8 * 8] = {

  // FNUM2/FNUM = 0 00xxxxxx (0x0000)
  0, 0, 0, 0, 0, 0, 0, 0,

  // FNUM2/FNUM = 0 01xxxxxx (0x0040)
  1, 0, 0, 0,-1, 0, 0, 0,

  // FNUM2/FNUM = 0 10xxxxxx (0x0080)
  2, 1, 0,-1,-2,-1, 0, 1,

  // FNUM2/FNUM = 0 11xxxxxx (0x00C0)
  3, 1, 0,-1,-3,-1, 0, 1,

  // FNUM2/FNUM = 1 00xxxxxx (0x0100)
  4, 2, 0,-2,-4,-2, 0, 2,

  // FNUM2/FNUM = 1 01xxxxxx (0x0140)
  5, 2, 0,-2,-5,-2, 0, 2,

  // FNUM2/FNUM = 1 10xxxxxx (0x0180)
  6, 3, 0,-3,-6,-3, 0, 3,

  // FNUM2/FNUM = 1 11xxxxxx (0x01C0)
  7, 3, 0,-3,-7,-3, 0, 3,
};

//------------------------------------------------------------------------------

// This is not 100% perfect yet but very close
// 
// - multi parameters are 100% correct (instruments and drums)
// - LFO PM and AM enable are 100% correct
// - waveform DC and DM select are 100% correct
// 2021/04/23: corrected with values extracted from YM2413 instrument ROM, cf. https://siliconpr0n.org/archive/doku.php?id=vendor:yamaha:opl2#ym2413_instrument_rom
unsigned char Ym2413::kTable[19][8] = {
// MULT  MULT modTL DcDmFb AR/DR AR/DR SL/RR SL/RR
//   0     1     2     3     4     5     6    7
/*{0x49, 0x4c, 0x4c, 0x12, 0x00, 0x00, 0x00, 0x00 }, */ /* 0 */
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  /* 0 */

/*{0x61, 0x61, 0x1e, 0x17, 0xf0, 0x78, 0x00, 0x17 }, */ /* 1 */
  {0x71, 0x61, 0x1e, 0x17, 0xd0, 0x78, 0x00, 0x17 }, /* 1 */

/*{0x13, 0x41, 0x1e, 0x0d, 0xd7, 0xf7, 0x13, 0x13 }, */ /* 2 */
  {0x13, 0x41, 0x1a, 0x0d, 0xd8, 0xf7, 0x23, 0x13 }, /* 2 */

/*{0x13, 0x01, 0x99, 0x04, 0xf2, 0xf4, 0x11, 0x23 }, */ /* 3 */
  {0x13, 0x01, 0x99, 0x00, 0xf2, 0xc4, 0x11, 0x23 }, /* 3 */

/*{0x21, 0x61, 0x1b, 0x07, 0xaf, 0x64, 0x40, 0x27 }, */ /* 4 */
  {0x31, 0x61, 0x0e, 0x07, 0xa8, 0x64, 0x70, 0x27 }, /* 4 */

/*{0x22, 0x21, 0x1e, 0x09, 0xf0, 0x76, 0x08, 0x28 },  */ /* 5 */
/*{0x22, 0x21, 0x1e, 0x06, 0xf0, 0x75, 0x08, 0x18 },  */ /* 5 */
  {0x32, 0x21, 0x1e, 0x06, 0xe0, 0x76, 0x00, 0x28 }, /* 5 */

/*{0x31, 0x22, 0x16, 0x09, 0x90, 0x7f, 0x00, 0x08 },  */ /* 6 */
/*{0x31, 0x22, 0x16, 0x05, 0x90, 0x71, 0x00, 0x13 },  */ /* 6 */
  {0x31, 0x22, 0x16, 0x05, 0xe0, 0x71, 0x00, 0x18 }, /* 6 */

/*{0x21, 0x61, 0x1d, 0x07, 0x82, 0x80, 0x10, 0x17 },  */ /* 7 */
  {0x21, 0x61, 0x1d, 0x07, 0x82, 0x81, 0x10, 0x07 }, /* 7 */

/*{0x23, 0x21, 0x2d, 0x16, 0xc0, 0x70, 0x07, 0x07 },  */ /* 8 */
  {0x23, 0x21, 0x2d, 0x14, 0xa2, 0x72, 0x00, 0x07 }, /* 8 */

  {0x61, 0x61, 0x1b, 0x06, 0x64, 0x65, 0x10, 0x17 }, /* 9 */

/*{0x61, 0x61, 0x0c, 0x08, 0x85, 0xa0, 0x79, 0x07 },  */ /* A */
/*{0x61, 0x61, 0x0c, 0x18, 0x85, 0xf0, 0x70, 0x07 },  */ /* A */
  {0x41, 0x61, 0x0b, 0x18, 0x85, 0xf7, 0x71, 0x07 }, /* A */

/*{0x23, 0x01, 0x07, 0x11, 0xf0, 0xa4, 0x00, 0x22 },  */ /* B */
  {0x13, 0x01, 0x83, 0x11, 0xfa, 0xe4, 0x10, 0x04 }, /* B */

/*{0x97, 0xc1, 0x24, 0x07, 0xff, 0xf8, 0x22, 0x12 },  */ /* C */
  {0x17, 0xc1, 0x24, 0x07, 0xf8, 0xf8, 0x22, 0x12 }, /* C */

/*{0x61, 0x10, 0x0c, 0x08, 0xf2, 0xc4, 0x40, 0xc8 },  */ /* D */
/*{0x61, 0x10, 0x0c, 0x05, 0xf2, 0xf4, 0x40, 0x44 },  */ /* D */
  {0x61, 0x50, 0x0c, 0x05, 0xc2, 0xf5, 0x20, 0x42 }, /* D */

/*{0x01, 0x01, 0x55, 0x03, 0xf3, 0x92, 0xf3, 0xf3 },  */ /* E */
  {0x01, 0x01, 0x55, 0x03, 0xc9, 0x95, 0x03, 0x02 }, /* E */

/*{0x61, 0x41, 0x89, 0x03, 0xf1, 0xf4, 0xf0, 0x13 },  */ /* F */
  {0x61, 0x41, 0x89, 0x03, 0xf1, 0xe4, 0x40, 0x13 }, /* F */

/* drum instruments definitions */
/* MULTI MULTI modTL  xxx  AR/DR AR/DR SL/RR SL/RR */
/*   0     1     2     3     4     5     6    7    */
/*{0x01, 0x01, 0x16, 0x00, 0xfd, 0xf8, 0x2f, 0x6d },*/ /* BD(multi verified, modTL verified, mod env - verified(close), carr. env verifed) */
/*{0x01, 0x01, 0x00, 0x00, 0xd8, 0xd8, 0xf9, 0xf8 },*/ /* HH(multi verified), SD(multi not used) */
/*{0x05, 0x01, 0x00, 0x00, 0xf8, 0xba, 0x49, 0x55 },*/ /* TOM(multi,env verified), TOP CYM(multi verified, env verified) */
  {0x01, 0x01, 0x18, 0x0f, 0xdf, 0xf8, 0x6a, 0x6d }, /* BD */
  {0x01, 0x01, 0x00, 0x00, 0xc8, 0xd8, 0xa7, 0x48 }, /* HH, SD */
  {0x05, 0x01, 0x00, 0x00, 0xf8, 0xaa, 0x59, 0x55 }  /* TOM, TOP CYM */
};

//------------------------------------------------------------------------------

Ym2413::Ym2413()
{
  xee::mem::Memset(&m_tl_tab, 0, sizeof(m_tl_tab));
  xee::mem::Memset(&m_sin_tab, 0, sizeof(m_sin_tab));
  xee::mem::Memset(&m_output, 0, sizeof(m_output));
  m_LFO_AM = 0;
  m_LFO_PM = 0;

  ClearContext();
}

//------------------------------------------------------------------------------

// advance LFO to next sample.
void Ym2413::advance_lfo()
{
  // LFO.
  m_lfo_am_cnt += m_lfo_am_inc;
  if (m_lfo_am_cnt >= (kLfoAmTabElements << LFO_SH))  // kLfoAmTable is 210 elements long.
    m_lfo_am_cnt -= (kLfoAmTabElements << LFO_SH);

  m_LFO_AM = kLfoAmTable[m_lfo_am_cnt >> LFO_SH] >> 1;

  m_lfo_pm_cnt += m_lfo_pm_inc;
  m_LFO_PM = (m_lfo_pm_cnt >> LFO_SH) & 7;
}

//------------------------------------------------------------------------------

// advance to next sample.
void Ym2413::advance()
{
  OPLL_CH* CH;
  OPLL_SLOT* op;
  unsigned int i;

  // Envelope Generator.
  m_eg_timer += m_eg_timer_add;

  while (m_eg_timer >= m_eg_timer_overflow) {
    m_eg_timer -= m_eg_timer_overflow;

    m_eg_cnt++;

    for (i = 0; i < 9 * 2; i++) {
      CH = &m_P_CH[i >> 1];

      op = &CH->SLOT[i & 1];

      switch (op->state) {
        case EG_DMP:  // dump phase.
          if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
          {
            op->state = EG_ATT;

            // force envelope to zero when attack rate is set to 15.0-15.3.
            if ((op->ar + op->ksr) >= 16 + 60) {
              op->volume = MIN_ATT_INDEX;
            }

            // dump phase is performed by both operators in each channel
            // when CARRIER envelope gets down to zero level,
            // phases in BOTH operators are reset (at the same time ?)
            if (i & 1) {
              CH->SLOT[0].phase = CH->SLOT[1].phase = 0;
            }
          } else if (!(m_eg_cnt & ((1 << op->eg_sh_dp) - 1))) {
            op->volume += kEgInc[op->eg_sel_dp + ((m_eg_cnt >> op->eg_sh_dp) & 15)];
          }
          break;

        case EG_ATT:  // attack phase.
          if (op->volume == MIN_ATT_INDEX) {
            op->state = EG_DEC;
          } else if (!(m_eg_cnt & (((1 << op->eg_sh_ar) - 1) & ~3))) {
            op->volume += (~op->volume * (kEgMul[op->eg_sel_ar + ((m_eg_cnt >> op->eg_sh_ar) & 15)])) >> 4;
          }
          break;

        case EG_DEC:  // decay phase.
          if ((op->volume & ~7) == op->sl)  // envelope level lowest 3 bits are ignored by the comparator.
          {
            op->state = EG_SUS;
          } else if (!(m_eg_cnt & ((1 << op->eg_sh_dr) - 1))) {
            op->volume += kEgInc[op->eg_sel_dr + ((m_eg_cnt >> op->eg_sh_dr) & 15)];
            if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
            {
              op->state = EG_OFF;
            }
          }
          break;

        case EG_SUS:  // sustain phase.
          // this is important behaviour:
          // one can change percusive/non-percussive modes on the fly and
          // the chip will remain in sustain phase - verified on real YM3812.

          if (op->eg_type)  // non-percussive mode (sustained tone).
          {
            // do nothing.
          } else  // percussive mode.
          {
            // during sustain phase chip adds Release Rate (in percussive mode).
            if (!(m_eg_cnt & ((1 << op->eg_sh_rr) - 1))) {
              op->volume += kEgInc[op->eg_sel_rr + ((m_eg_cnt >> op->eg_sh_rr) & 15)];
              if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
              {
                op->state = EG_OFF;
              }
            }
            // else do nothing in sustain phase.
          }
          break;

        case EG_REL:  // release phase.
          // exclude modulators in melody channels from performing anything in this mode
          // allowed are only carriers in melody mode and rhythm slots in rhythm mode.

          // This table shows which operators and on what conditions are allowed to perform EG_REL:
          // (a) - always perform EG_REL
          // (n) - never perform EG_REL
          // (r) - perform EG_REL in Rhythm mode ONLY
          //   0: 0 (n),  1 (a)
          //   1: 2 (n),  3 (a)
          //   2: 4 (n),  5 (a)
          //   3: 6 (n),  7 (a)
          //   4: 8 (n),  9 (a)
          //   5: 10(n),  11(a)
          //   6: 12(r),  13(a)
          //   7: 14(r),  15(a)
          //   8: 16(r),  17(a)
          if ((i & 1) || ((m_rhythm & 0x20) && (i >= 12)))// exclude modulators.
          {
            if (op->eg_type)  // non-percussive mode (sustained tone).
              // this is correct: use RR when SUS = OFF
              // and use RS when SUS = ON
            {
              if (CH->sus) {
                if (!(m_eg_cnt & ((1 << op->eg_sh_rs) - 1))) {
                  op->volume += kEgInc[op->eg_sel_rs + ((m_eg_cnt >> op->eg_sh_rs) & 15)];
                  if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
                  {
                    op->state = EG_OFF;
                  }
                }
              } else {
                if (!(m_eg_cnt & ((1 << op->eg_sh_rr) - 1))) {
                  op->volume += kEgInc[op->eg_sel_rr + ((m_eg_cnt >> op->eg_sh_rr) & 15)];
                  if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
                  {
                    op->state = EG_OFF;
                  }
                }
              }
            } else  // percussive mode.
            {
              if (!(m_eg_cnt & ((1 << op->eg_sh_rs) - 1))) {
                op->volume += kEgInc[op->eg_sel_rs + ((m_eg_cnt >> op->eg_sh_rs) & 15)];
                if ((op->volume & ~3) == (MAX_ATT_INDEX & ~3))  // envelope level lowest 2 bits are ignored by the comparator.
                {
                  op->state = EG_OFF;
                }
              }
            }
          }
          break;

        case EG_OFF:  // envelope off.
          op->volume = MAX_ATT_INDEX;
          break;

        default:
          break;
      }
    }
  }

  for (i = 0; i < 9 * 2; i++) {
    CH = &m_P_CH[i / 2];
    op = &CH->SLOT[i & 1];

    // Phase Generator.
    if (op->vib) {
      u8 block;

      unsigned int fnum_lfo = 8 * ((CH->block_fnum & 0x01c0) >> 6);
      unsigned int block_fnum = CH->block_fnum * 2;
      signed int lfo_fn_table_index_offset = kLfoPmTable[m_LFO_PM + fnum_lfo];

      if (lfo_fn_table_index_offset)  // LFO phase modulation active.
      {
        block_fnum += lfo_fn_table_index_offset;
        block = (block_fnum & 0x1c00) >> 10;
        op->phase += (m_fn_tab[block_fnum & 0x03ff] >> (7 - block)) * op->mul;
      } else  // LFO phase modulation  = zero.
      {
        op->phase += op->freq;
      }
    } else  // LFO phase modulation disabled for this operator.
    {
      op->phase += op->freq;
    }
  }

  // The Noise Generator of the YM3812 is 23-bit shift register.
  // Period is equal to 2^23-2 samples.
  // Register works at sampling frequency of the chip, so output
  // can change on every sample.
  // 
  // Output of the register and input to the bit 22 is:
  // bit0 XOR bit14 XOR bit15 XOR bit22
  // 
  // Simply use bit 22 as the noise output.

  m_noise_p += m_noise_f;
  i = m_noise_p >> FREQ_SH;    // number of events (shifts of the shift register).
  m_noise_p &= FREQ_MASK;
  while (i) {
    /*
    u32 j;
    j = ( (chip->noise_rng) ^ (chip->noise_rng>>14) ^ (chip->noise_rng>>15) ^ (chip->noise_rng>>22) ) & 1;
    chip->noise_rng = (j<<22) | (chip->noise_rng>>1);
    */

    //  Instead of doing all the logic operations above, we
    //  use a trick here (and use bit 0 as the noise output).
    //  The difference is only that the noise bit changes one
    //  step ahead. This doesn't matter since we don't know
    //  what is real state of the noise_rng after the reset.

    if (m_noise_rng & 1) m_noise_rng ^= 0x800302;
    m_noise_rng >>= 1;

    i--;
  }
}

//------------------------------------------------------------------------------

signed int Ym2413::op_calc(u32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
{
  u32 p = (env << 5) + m_sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + (pm << 17))) >> FREQ_SH) & SIN_MASK)];

  if (p >= kTlTabLen)
    return 0;
  return m_tl_tab[p];
}

//------------------------------------------------------------------------------

signed int Ym2413::op_calc1(u32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
{
  u32 p = (env << 5) + m_sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + pm)) >> FREQ_SH) & SIN_MASK)];

  if (p >= kTlTabLen)
    return 0;
  return m_tl_tab[p];
}

//------------------------------------------------------------------------------

#define volume_calc(OP) (((OP)-> state != EG_OFF) ? (OP)->TLL + ((u32)(OP)->volume) + (m_LFO_AM & (OP)->AMmask) : ENV_QUIET)

//------------------------------------------------------------------------------

// calculate output.
void Ym2413::chan_calc(OPLL_CH* CH)
{
  OPLL_SLOT* SLOT;
  unsigned int env;
  signed int out;
  signed int phase_modulation;  // phase modulation input (SLOT 2).

  // SLOT 1.
  SLOT = &CH->SLOT[SLOT1];
  env = volume_calc(SLOT);
  out = SLOT->op1_out[0] + SLOT->op1_out[1];

  SLOT->op1_out[0] = SLOT->op1_out[1];
  phase_modulation = SLOT->op1_out[0];

  SLOT->op1_out[1] = 0;

  if (env < ENV_QUIET) {
    if (!SLOT->fb_shift)
      out = 0;
    SLOT->op1_out[1] = op_calc1(SLOT->phase, env, (out << SLOT->fb_shift), SLOT->wavetable);
  }

  // SLOT 2.

  SLOT++;
  env = volume_calc(SLOT);
  if (env < ENV_QUIET) {
    m_output[0] += op_calc(SLOT->phase, env, phase_modulation, SLOT->wavetable);
  }
}

//------------------------------------------------------------------------------

//   operators used in the rhythm sounds generation process:
// 
//   Envelope Generator:
// 
// channel  operator  register number   Bass  High  Snare Tom  Top
// / slot   number    TL ARDR SLRR Wave Drum  Hat   Drum  Tom  Cymbal
//  6 / 0   12        50  70   90   f0  +
//  6 / 1   15        53  73   93   f3  +
//  7 / 0   13        51  71   91   f1        +
//  7 / 1   16        54  74   94   f4              +
//  8 / 0   14        52  72   92   f2                    +
//  8 / 1   17        55  75   95   f5                          +
// 
//   Phase Generator:
// 
// channel  operator  register number   Bass  High  Snare Tom  Top
// / slot   number    MULTIPLE          Drum  Hat   Drum  Tom  Cymbal
//  6 / 0   12        30                +
//  6 / 1   15        33                +
//  7 / 0   13        31                      +     +           +
//  7 / 1   16        34                -----  n o t  u s e d -----
//  8 / 0   14        32                                  +
//  8 / 1   17        35                      +                 +
// 
// channel  operator  register number   Bass  High  Snare Tom  Top
// number   number    BLK/FNUM2 FNUM    Drum  Hat   Drum  Tom  Cymbal
//    6     12,15     B6        A6      +
// 
//    7     13,16     B7        A7            +     +           +
// 
//    8     14,17     B8        A8            +           +     +
// 

// calculate rhythm.
void Ym2413::rhythm_calc(OPLL_CH* CH, unsigned int noise)
{
  OPLL_SLOT* SLOT;
  signed int out;
  unsigned int env;
  signed int phase_modulation;  // phase modulation input (SLOT 2).

  // Bass Drum (verified on real YM3812):
  // - depends on the channel 6 'connect' register:
  //     when connect = 0 it works the same as in normal (non-rhythm) mode (op1->op2->out)
  //     when connect = 1 _only_ operator 2 is present on output (op2->out), operator 1 is ignored
  // - output sample always is multiplied by 2


  // SLOT 1.
  SLOT = &CH[6].SLOT[SLOT1];
  env = volume_calc(SLOT);

  out = SLOT->op1_out[0] + SLOT->op1_out[1];
  SLOT->op1_out[0] = SLOT->op1_out[1];

  phase_modulation = SLOT->op1_out[0];

  SLOT->op1_out[1] = 0;
  if (env < ENV_QUIET) {
    if (!SLOT->fb_shift)
      out = 0;
    SLOT->op1_out[1] = op_calc1(SLOT->phase, env, (out << SLOT->fb_shift), SLOT->wavetable);
  }

  // SLOT 2.
  SLOT++;
  env = volume_calc(SLOT);
  if (env < ENV_QUIET)
    m_output[1] += op_calc(SLOT->phase, env, phase_modulation, SLOT->wavetable);


  // Phase generation is based on:
  // HH  (13) channel 7->slot 1 combined with channel 8->slot 2 (same combination as TOP CYMBAL but different output phases)
  // SD  (16) channel 7->slot 1
  // TOM (14) channel 8->slot 1
  // TOP (17) channel 7->slot 1 combined with channel 8->slot 2 (same combination as HIGH HAT but different output phases)

  // Envelope generation based on:
  // HH  channel 7->slot1
  // SD  channel 7->slot2
  // TOM channel 8->slot1
  // TOP channel 8->slot2

  // The following formulas can be well optimized.
  // I leave them in direct form for now (in case I've missed something).

  // High Hat (verified on real YM3812).
  env = volume_calc(&CH[7].SLOT[SLOT1]);
  if (env < ENV_QUIET) {

    // high hat phase generation:
    // phase = d0 or 234 (based on frequency only)
    // phase = 34 or 2d0 (based on noise)

    // base frequency derived from operator 1 in channel 7.
    unsigned char bit7 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 7) & 1;
    unsigned char bit3 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 3) & 1;
    unsigned char bit2 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 2) & 1;

    unsigned char res1 = (bit2 ^ bit7) | bit3;

    // when res1 = 0 phase = 0x000 | 0xd0;
    // when res1 = 1 phase = 0x200 | (0xd0>>2);
    u32 phase = res1 ? (0x200 | (0xd0 >> 2)) : 0xd0;

    // enable gate based on frequency of operator 2 in channel 8.
    unsigned char bit5e = ((CH[8].SLOT[SLOT2].phase >> FREQ_SH) >> 5) & 1;
    unsigned char bit3e = ((CH[8].SLOT[SLOT2].phase >> FREQ_SH) >> 3) & 1;

    unsigned char res2 = (bit3e | bit5e);

    // when res2 = 0 pass the phase from calculation above (res1);
    // when res2 = 1 phase = 0x200 | (0xd0>>2);
    if (res2)
      phase = (0x200 | (0xd0 >> 2));


    // when phase & 0x200 is set and noise=1 then phase = 0x200|0xd0
    // when phase & 0x200 is set and noise=0 then phase = 0x200|(0xd0>>2), ie no change
    if (phase & 0x200) {
      if (noise)
        phase = 0x200 | 0xd0;
    } else
      // when phase & 0x200 is clear and noise=1 then phase = 0xd0>>2
      // when phase & 0x200 is clear and noise=0 then phase = 0xd0, ie no change
    {
      if (noise)
        phase = 0xd0 >> 2;
    }

    m_output[1] += op_calc(phase << FREQ_SH, env, 0, CH[7].SLOT[SLOT1].wavetable);
  }

  // Snare Drum (verified on real YM3812).
  env = volume_calc(&CH[7].SLOT[SLOT2]);
  if (env < ENV_QUIET) {
    // base frequency derived from operator 1 in channel 7.
    unsigned char bit8 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 8) & 1;

    // when bit8 = 0 phase = 0x100;
    // when bit8 = 1 phase = 0x200;
    u32 phase = bit8 ? 0x200 : 0x100;

    // Noise bit XOR'es phase by 0x100.
    // when noisebit = 0 pass the phase from calculation above
    // when noisebit = 1 phase ^= 0x100;
    // in other words: phase ^= (noisebit<<8);
    if (noise)
      phase ^= 0x100;

    m_output[1] += op_calc(phase << FREQ_SH, env, 0, CH[7].SLOT[SLOT2].wavetable);
  }

  // Tom Tom (verified on real YM3812).
  env = volume_calc(&CH[8].SLOT[SLOT1]);
  if (env < ENV_QUIET)
    m_output[1] += op_calc(CH[8].SLOT[SLOT1].phase, env, 0, CH[8].SLOT[SLOT1].wavetable);

  // Top Cymbal (verified on real YM2413).
  env = volume_calc(&CH[8].SLOT[SLOT2]);
  if (env < ENV_QUIET) {
    // base frequency derived from operator 1 in channel 7.
    unsigned char bit7 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 7) & 1;
    unsigned char bit3 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 3) & 1;
    unsigned char bit2 = ((CH[7].SLOT[SLOT1].phase >> FREQ_SH) >> 2) & 1;

    unsigned char res1 = (bit2 ^ bit7) | bit3;

    // when res1 = 0 phase = 0x000 | 0x100;
    // when res1 = 1 phase = 0x200 | 0x100;
    u32 phase = res1 ? 0x300 : 0x100;

    // enable gate based on frequency of operator 2 in channel 8.
    unsigned char bit5e = ((CH[8].SLOT[SLOT2].phase >> FREQ_SH) >> 5) & 1;
    unsigned char bit3e = ((CH[8].SLOT[SLOT2].phase >> FREQ_SH) >> 3) & 1;

    unsigned char res2 = (bit3e | bit5e);
    // when res2 = 0 pass the phase from calculation above (res1);
    // when res2 = 1 phase = 0x200 | 0x100;
    if (res2)
      phase = 0x300;

    m_output[1] += op_calc(phase << FREQ_SH, env, 0, CH[8].SLOT[SLOT2].wavetable);
  }
}

//------------------------------------------------------------------------------

// generic table initialize.
int Ym2413::init_tables()
{
  signed int i, x;
  signed int n;
  f64 o, m;

  for (x = 0; x < kTlResLen; x++) {
    m = (1 << 16) / pow(2, (x + 1) * (ENV_STEP / 4.0) / 8.0);
    m = floor(m);

    // we never reach (1<<16) here due to the (x+1).
    // result fits within 16 bits at maximum.

    n = (int)m;    // 16 bits here.
    n >>= 4;    // 12 bits here.
    if (n & 1)    // round to nearest.
      n = (n >> 1) + 1;
    else
      n = n >> 1;
    // 11 bits here (rounded).
    m_tl_tab[x * 2 + 0] = n;
    m_tl_tab[x * 2 + 1] = -m_tl_tab[x * 2 + 0];

    for (i = 1; i < 11; i++) {
      m_tl_tab[x * 2 + 0 + i * 2 * kTlResLen] = m_tl_tab[x * 2 + 0] >> i;
      m_tl_tab[x * 2 + 1 + i * 2 * kTlResLen] = -m_tl_tab[x * 2 + 0 + i * 2 * kTlResLen];
    }
  }

  for (i = 0; i < kSinLen; i++) {
    // non-standard sinus.
    m = sin(((i * 2) + 1) * M_PI / kSinLen); // checked against the real chip.

    // we never reach zero here due to ((i*2)+1).

    if (m > 0.0)
      o = 8 * log(1.0 / m) / log(2);  // convert to 'decibels'.
    else
      o = 8 * log(-1.0 / m) / log(2);  // convert to 'decibels'.

    o = o / (ENV_STEP / 4);

    n = (int)(2.0 * o);
    if (n & 1)            // round to nearest.
      n = (n >> 1) + 1;
    else
      n = n >> 1;

    // waveform 0: standard sinus.
    m_sin_tab[i] = n * 2 + (m >= 0.0 ? 0 : 1);

    // waveform 1:  __      __     
    //             /  \____/  \____
    // output only first half of the sinus waveform (positive one).
    if (i & (1 << (kSinBits - 1)))
      m_sin_tab[1 * kSinLen + i] = kTlTabLen;
    else
      m_sin_tab[1 * kSinLen + i] = m_sin_tab[i];
  }

  return 1;
}

//------------------------------------------------------------------------------

void Ym2413::OPLL_initalize()
{
  int i;

  // YM2413 always running at original frequency.
  f64 freqbase = 1.0;

  // make fnumber -> increment counter table.
  for (i = 0; i < 1024; i++) {
    // OPLL (YM2413) phase increment counter = 18bit
    m_fn_tab[i] = (u32)((f64)i * 64 * freqbase * (1 << (FREQ_SH - 10))); // -10 because chip works with 10.10 fixed point, while we use 16.16
  }

  // Amplitude modulation: 27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples.
  // One entry from LFO_AM_TABLE lasts for 64 samples.
  m_lfo_am_inc = (1.0 / 64.0) * (1 << LFO_SH) * freqbase;

  // Vibrato: 8 output levels (triangle waveform); 1 level takes 1024 samples.
  m_lfo_pm_inc = (1.0 / 1024.0) * (1 << LFO_SH) * freqbase;

  // Noise generator: a step takes 1 sample.
  m_noise_f = (1.0 / 1.0) * (1 << FREQ_SH) * freqbase;

  m_eg_timer_add = (1 << EG_SH) * freqbase;
  m_eg_timer_overflow = (1) * (1 << EG_SH);
}

//------------------------------------------------------------------------------

void Ym2413::KEY_ON(OPLL_SLOT* SLOT, u32 key_set)
{
  if (!SLOT->key) {
    // do NOT restart Phase Generator (verified on real YM2413).
    // phase -> Dump.
    SLOT->state = EG_DMP;
  }
  SLOT->key |= key_set;
}

//------------------------------------------------------------------------------

void Ym2413::KEY_OFF(OPLL_SLOT* SLOT, u32 key_clr)
{
  if (SLOT->key) {
    SLOT->key &= key_clr;

    if (!SLOT->key) {
      // phase -> Release (forced off if already at maximal attenuation level).
      SLOT->state = ((SLOT->volume & ~3) == (MAX_ATT_INDEX & ~3)) ? EG_OFF : EG_REL;
    }
  }
}

//------------------------------------------------------------------------------

// update phase increment counter of operator (also update the EG rates if necessary).
void Ym2413::CALC_FCSLOT(OPLL_CH* CH, OPLL_SLOT* SLOT)
{
  int ksr;
  u32 SLOT_rs;
  u32 SLOT_dp;

  // (frequency) phase increment counter.
  SLOT->freq = CH->fc * SLOT->mul;
  ksr = CH->kcode >> SLOT->KSR;

  if (SLOT->ksr != ksr) {
    SLOT->ksr = ksr;

    // calculate envelope generator rates.
    if ((SLOT->ar + SLOT->ksr) >= 16 + 60) {
      // attack phase is skipped in case attack rate is set to 15.0-15.3 before attack phase is started 
      // during attack phase, in case attack rate is changed to 15.0-15.3, attack phase is blocked.
      // (verified on real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
      SLOT->eg_sh_ar = 13;
      SLOT->eg_sel_ar = 0 * kRateSteps;
    } else if ((SLOT->ar + SLOT->ksr) >= 16 + 48) {
      // attack rates 12.0 to 14.3 have similar specific behavior.
      // (verified on real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
      SLOT->eg_sh_ar = 0;
      SLOT->eg_sel_ar = kEgRateSelect[SLOT->ar + SLOT->ksr] + (4 * kRateSteps);
    } else {
      SLOT->eg_sh_ar = kEgRateShift[SLOT->ar + SLOT->ksr];
      SLOT->eg_sel_ar = kEgRateSelect[SLOT->ar + SLOT->ksr];
    }
    SLOT->eg_sh_dr = kEgRateShift[SLOT->dr + SLOT->ksr];
    SLOT->eg_sel_dr = kEgRateSelect[SLOT->dr + SLOT->ksr];
    SLOT->eg_sh_rr = kEgRateShift[SLOT->rr + SLOT->ksr];
    SLOT->eg_sel_rr = kEgRateSelect[SLOT->rr + SLOT->ksr];
  }

  if (CH->sus)
    SLOT_rs = 16 + (5 << 2);
  else
    SLOT_rs = 16 + (7 << 2);

  SLOT->eg_sh_rs = kEgRateShift[SLOT_rs + SLOT->ksr];
  SLOT->eg_sel_rs = kEgRateSelect[SLOT_rs + SLOT->ksr];

  SLOT_dp = 16 + (12 << 2);
  SLOT->eg_sh_dp = kEgRateShift[SLOT_dp + SLOT->ksr];
  SLOT->eg_sel_dp = kEgRateSelect[SLOT_dp + SLOT->ksr];
}

//------------------------------------------------------------------------------

// set multi,am,vib,EG-TYP,KSR,mul.
void Ym2413::set_mul(int slot, int v)
{
  OPLL_CH* CH = &m_P_CH[slot / 2];
  OPLL_SLOT* SLOT = &CH->SLOT[slot & 1];

  SLOT->mul = kMulTab[v & 0x0f];
  SLOT->KSR = (v & 0x10) ? 0 : 2;
  SLOT->eg_type = (v & 0x20);
  SLOT->vib = (v & 0x40);
  SLOT->AMmask = (v & 0x80) ? ~0 : 0;
  CALC_FCSLOT(CH, SLOT);
}

//------------------------------------------------------------------------------

// set ksl, tl.
void Ym2413::set_ksl_tl(int chan, int v)
{
  OPLL_CH* CH = &m_P_CH[chan];
  // modulator.
  OPLL_SLOT* SLOT = &CH->SLOT[SLOT1];

  int ksl = v >> 6; // 0 / 1.5 / 3.0 / 6.0 dB/OCT.

  SLOT->ksl = ksl ? 3 - ksl : 31;
  SLOT->TL = (v & 0x3f) << (ENV_BITS - 2 - 7); // 7 bits TL (bit 6 = always 0).
  SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);
}

//------------------------------------------------------------------------------

// set ksl , waveforms, feedback.
void Ym2413::set_ksl_wave_fb(int chan, int v)
{
  OPLL_CH* CH = &m_P_CH[chan];
  // modulator.
  OPLL_SLOT* SLOT = &CH->SLOT[SLOT1];
  SLOT->wavetable = ((v & 0x08) >> 3) * kSinLen;
  SLOT->fb_shift = (v & 7) ? (v & 7) + 8 : 0;

  // carrier.
  SLOT = &CH->SLOT[SLOT2];
  SLOT->wavetable = ((v & 0x10) >> 4) * kSinLen;
  v >>= 6; // 0 / 1.5 / 3.0 / 6.0 dB/OCT
  SLOT->ksl = v ? 3 - v : 31;
  SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);
}

//------------------------------------------------------------------------------

// set attack rate & decay rate.
void Ym2413::set_ar_dr(int slot, int v)
{
  OPLL_CH* CH = &m_P_CH[slot / 2];
  OPLL_SLOT* SLOT = &CH->SLOT[slot & 1];

  SLOT->ar = (v >> 4) ? 16 + ((v >> 4) << 2) : 0;

  if ((SLOT->ar + SLOT->ksr) >= 16 + 60) {
    // attack phase is skipped in case attack rate is set to 15.0-15.3 before attack phase is started 
    // during attack phase, in case attack rate is changed to 15.0-15.3, attack phase is blocked.
    // (verified on real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
    SLOT->eg_sh_ar = 13;
    SLOT->eg_sel_ar = 0 * kRateSteps;
  } else if ((SLOT->ar + SLOT->ksr) >= 16 + 48) {
    // attack rates 12.0 to 14.3 have similar specific behavior.
    // (verified on real hardware, cf. https://www.smspower.org/Development/YM2413ReverseEngineeringNotes2017-01-26)
    SLOT->eg_sh_ar = 0;
    SLOT->eg_sel_ar = kEgRateSelect[SLOT->ar + SLOT->ksr] + (4 * kRateSteps);
  } else {
    SLOT->eg_sh_ar = kEgRateShift[SLOT->ar + SLOT->ksr];
    SLOT->eg_sel_ar = kEgRateSelect[SLOT->ar + SLOT->ksr];
  }

  SLOT->dr = (v & 0x0f) ? 16 + ((v & 0x0f) << 2) : 0;
  SLOT->eg_sh_dr = kEgRateShift[SLOT->dr + SLOT->ksr];
  SLOT->eg_sel_dr = kEgRateSelect[SLOT->dr + SLOT->ksr];
}

//------------------------------------------------------------------------------

// set sustain level & release rate.
void Ym2413::set_sl_rr(int slot, int v)
{
  OPLL_CH* CH = &m_P_CH[slot / 2];
  OPLL_SLOT* SLOT = &CH->SLOT[slot & 1];

  SLOT->sl = kSustainLevelTable[v >> 4];

  SLOT->rr = (v & 0x0f) ? 16 + ((v & 0x0f) << 2) : 0;
  SLOT->eg_sh_rr = kEgRateShift[SLOT->rr + SLOT->ksr];
  SLOT->eg_sel_rr = kEgRateSelect[SLOT->rr + SLOT->ksr];
}

//------------------------------------------------------------------------------

void Ym2413::load_instrument(u32 chan, u32 slot, u8* inst)
{
  set_mul(slot, inst[0]);
  set_mul(slot + 1, inst[1]);
  set_ksl_tl(chan, inst[2]);
  set_ksl_wave_fb(chan, inst[3]);
  set_ar_dr(slot, inst[4]);
  set_ar_dr(slot + 1, inst[5]);
  set_sl_rr(slot, inst[6]);
  set_sl_rr(slot + 1, inst[7]);
}

//------------------------------------------------------------------------------

void Ym2413::update_instrument_zero(u8 r)
{
  u8* inst = &m_inst_tab[0][0]; // point to user instrument.
  u32 chan;

  u32 chan_max = 9;
  if (m_rhythm & 0x20)
    chan_max = 6;

  switch (r & 7) {
    case 0:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_mul(chan * 2, inst[0]);
        }
      }
      break;

    case 1:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_mul(chan * 2 + 1, inst[1]);
        }
      }
      break;

    case 2:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_ksl_tl(chan, inst[2]);
        }
      }
      break;

    case 3:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_ksl_wave_fb(chan, inst[3]);
        }
      }
      break;

    case 4:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_ar_dr(chan * 2, inst[4]);
        }
      }
      break;

    case 5:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_ar_dr(chan * 2 + 1, inst[5]);
        }
      }
      break;

    case 6:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_sl_rr(chan * 2, inst[6]);
        }
      }
      break;

    case 7:
      for (chan = 0; chan < chan_max; chan++) {
        if ((m_instvol_r[chan] & 0xf0) == 0) {
          set_sl_rr(chan * 2 + 1, inst[7]);
        }
      }
      break;
  }
}

//------------------------------------------------------------------------------

// write a value v to register r on chip chip.
void Ym2413::OPLLWriteReg(int r, int v)
{
  OPLL_CH* CH;
  OPLL_SLOT* SLOT;

  // adjust bus to 8 bits.
  r &= 0xff;
  v &= 0xff;

  switch (r & 0xf0) {
    case 0x00:  // 00-0f:control.
    {
      switch (r & 0x0f) {
        case 0x00:  // AM/VIB/EGTYP/KSR/MULTI (modulator).
        case 0x01:  // AM/VIB/EGTYP/KSR/MULTI (carrier).
        case 0x02:  // Key Scale Level, Total Level (modulator).
        case 0x03:  // Key Scale Level, carrier waveform, modulator waveform, Feedback.
        case 0x04:  // Attack, Decay (modulator).
        case 0x05:  // Attack, Decay (carrier).
        case 0x06:  // Sustain, Release (modulator).
        case 0x07:  // Sustain, Release (carrier).
        {
          m_inst_tab[0][r] = v;
          update_instrument_zero(r);
          break;
        }

        case 0x0e:  // x, x, r,bd,sd,tom,tc,hh.
        {
          if (v & 0x20) {
            // rhythm OFF to ON.
            if ((m_rhythm & 0x20) == 0) {
              // Load instrument settings for channel seven(chan=6 since we're zero based). (Bass drum).
              load_instrument(6, 12, &m_inst_tab[16][0]);

              // Load instrument settings for channel eight. (High hat and snare drum).
              load_instrument(7, 14, &m_inst_tab[17][0]);

              CH = &m_P_CH[7];
              SLOT = &CH->SLOT[SLOT1]; // modulator envelope is HH.
              SLOT->TL = ((m_instvol_r[7] >> 4) << 2) << (ENV_BITS - 2 - 7); // 7 bits TL (bit 6 = always 0).
              SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);

              // Load instrument settings for channel nine. (Tom-tom and top cymbal).
              load_instrument(8, 16, &m_inst_tab[18][0]);

              CH = &m_P_CH[8];
              SLOT = &CH->SLOT[SLOT1]; // modulator envelope is TOM.
              SLOT->TL = ((m_instvol_r[8] >> 4) << 2) << (ENV_BITS - 2 - 7); // 7 bits TL (bit 6 = always 0).
              SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);
            }

            // BD key on/off.
            if (v & 0x10) {
              KEY_ON(&m_P_CH[6].SLOT[SLOT1], 2);
              KEY_ON(&m_P_CH[6].SLOT[SLOT2], 2);
            } else {
              KEY_OFF(&m_P_CH[6].SLOT[SLOT1], ~2);
              KEY_OFF(&m_P_CH[6].SLOT[SLOT2], ~2);
            }

            // HH key on/off.
            if (v & 0x01) KEY_ON(&m_P_CH[7].SLOT[SLOT1], 2);
            else       KEY_OFF(&m_P_CH[7].SLOT[SLOT1], ~2);

            // SD key on/off.
            if (v & 0x08) KEY_ON(&m_P_CH[7].SLOT[SLOT2], 2);
            else       KEY_OFF(&m_P_CH[7].SLOT[SLOT2], ~2);

            // TOM key on/off.
            if (v & 0x04) KEY_ON(&m_P_CH[8].SLOT[SLOT1], 2);
            else       KEY_OFF(&m_P_CH[8].SLOT[SLOT1], ~2);

            // TOP-CY key on/off.
            if (v & 0x02) KEY_ON(&m_P_CH[8].SLOT[SLOT2], 2);
            else       KEY_OFF(&m_P_CH[8].SLOT[SLOT2], ~2);
          } else {
            // rhythm ON to OFF.
            if (m_rhythm & 0x20) {
              // Load instrument settings for channel seven(chan=6 since we're zero based).
              load_instrument(6, 12, &m_inst_tab[m_instvol_r[6] >> 4][0]);

              // Load instrument settings for channel eight.
              load_instrument(7, 14, &m_inst_tab[m_instvol_r[7] >> 4][0]);

              // Load instrument settings for channel nine.
              load_instrument(8, 16, &m_inst_tab[m_instvol_r[8] >> 4][0]);
            }

            // BD key off.
            KEY_OFF(&m_P_CH[6].SLOT[SLOT1], ~2);
            KEY_OFF(&m_P_CH[6].SLOT[SLOT2], ~2);

            // HH key off.
            KEY_OFF(&m_P_CH[7].SLOT[SLOT1], ~2);

            // SD key off.
            KEY_OFF(&m_P_CH[7].SLOT[SLOT2], ~2);

            // TOM key off.
            KEY_OFF(&m_P_CH[8].SLOT[SLOT1], ~2);

            // TOP-CY off.
            KEY_OFF(&m_P_CH[8].SLOT[SLOT2], ~2);
          }

          m_rhythm = v & 0x3f;
          break;
        }
      }

      break;
    }

    case 0x10:
    case 0x20:
    {
      int block_fnum;

      int chan = r & 0x0f;

      if (chan >= 9)
        chan -= 9;  // verified on real YM2413.

      CH = &m_P_CH[chan];

      if (r & 0x10) {
        // 10-18: FNUM 0-7
        block_fnum = (CH->block_fnum & 0x0f00) | v;
      } else {
        // 20-28: suson, keyon, block, FNUM 8
        block_fnum = ((v & 0x0f) << 8) | (CH->block_fnum & 0xff);

        if (v & 0x10) {
          KEY_ON(&CH->SLOT[SLOT1], 1);
          KEY_ON(&CH->SLOT[SLOT2], 1);
        } else {
          KEY_OFF(&CH->SLOT[SLOT1], ~1);
          KEY_OFF(&CH->SLOT[SLOT2], ~1);
        }

        CH->sus = v & 0x20;
      }

      // update.
      if (CH->block_fnum != block_fnum) {
        u8 block;
        CH->block_fnum = block_fnum;

        // BLK 2,1,0 bits -> bits 3,2,1 of kcode, FNUM MSB -> kcode LSB
        CH->kcode = (block_fnum & 0x0f00) >> 8;

        CH->ksl_base = kKeyScaleLevelTable[block_fnum >> 5];

        block_fnum = block_fnum * 2;
        block = (block_fnum & 0x1c00) >> 10;
        CH->fc = m_fn_tab[block_fnum & 0x03ff] >> (7 - block);

        // refresh Total Level in both SLOTs of this channel.
        CH->SLOT[SLOT1].TLL = CH->SLOT[SLOT1].TL + (CH->ksl_base >> CH->SLOT[SLOT1].ksl);
        CH->SLOT[SLOT2].TLL = CH->SLOT[SLOT2].TL + (CH->ksl_base >> CH->SLOT[SLOT2].ksl);

        // refresh frequency counter in both SLOTs of this channel.
        CALC_FCSLOT(CH, &CH->SLOT[SLOT1]);
        CALC_FCSLOT(CH, &CH->SLOT[SLOT2]);
      }

      break;
    }

    case 0x30:  // inst 4 MSBs, VOL 4 LSBs.
    {
      int chan = r & 0x0f;

      if (chan >= 9)
        chan -= 9;  // verified on real YM2413.

      CH = &m_P_CH[chan];
      SLOT = &CH->SLOT[SLOT2]; // carrier
      SLOT->TL = ((v & 0x0f) << 2) << (ENV_BITS - 2 - 7); // 7 bits TL (bit 6 = always 0)
      SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);

      // check wether we are in rhythm mode and handle instrument/volume register accordingly.
      if ((chan >= 6) && (m_rhythm & 0x20)) {
        // we're in rhythm mode.

        if (chan >= 7) // only for channel 7 and 8 (channel 6 is handled in usual way).
        {
          SLOT = &CH->SLOT[SLOT1]; // modulator envelope is HH(chan=7) or TOM(chan=8).
          SLOT->TL = ((v >> 4) << 2) << (ENV_BITS - 2 - 7); // 7 bits TL (bit 6 = always 0).
          SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);
        }
      } else {
        if ((m_instvol_r[chan] & 0xf0) != (v & 0xf0)) {
          m_instvol_r[chan] = v;  // store for later use.
          load_instrument(chan, chan * 2, &m_inst_tab[v >> 4][0]);
        }
      }

      break;
    }

    default:
      break;
  }
}

//------------------------------------------------------------------------------

void Ym2413::YM2413Init()
{
  init_tables();

  // clear.
  ClearContext();

  // init global tables.
  OPLL_initalize();
}

//------------------------------------------------------------------------------

void Ym2413::YM2413ResetChip()
{
  int c, s;
  int i;

  m_eg_timer = 0;
  m_eg_cnt = 0;

  m_noise_rng = 1;  // noise shift register.


  // setup instruments table.
  for (i = 0; i < 19; i++) {
    for (c = 0; c < 8; c++) {
      m_inst_tab[i][c] = kTable[i][c];
    }
  }


  // reset with register write.
  OPLLWriteReg(0x0f, 0); // test reg.
  for (i = 0x3f; i >= 0x10; i--) OPLLWriteReg(i, 0x00);

  // reset operator parameters.
  for (c = 0; c < 9; c++) {
    OPLL_CH* CH = &m_P_CH[c];
    for (s = 0; s < 2; s++) {
      // wave table.
      CH->SLOT[s].wavetable = 0;
      CH->SLOT[s].state = EG_OFF;
      CH->SLOT[s].volume = MAX_ATT_INDEX;
    }
  }
}

//------------------------------------------------------------------------------

// YM2413 I/O interface.

void Ym2413::YM2413Write(unsigned int a, unsigned int v)
{
  if (!(a & 2)) {
    if (!(a & 1)) {
      // address port.
      m_address = v & 0xff;
    } else {
      // data port.
      OPLLWriteReg(m_address, v);
    }
  } else {
    // bit 0 enable/disable FM output (Master System / Mark-III FM adapter specific).
    m_status = v & 0x01;
  }
}

//------------------------------------------------------------------------------

unsigned int Ym2413::YM2413Read()
{
  // bit 0 returns latched FM enable status, bits 1-2 return zero (Master System / Mark-III FM adapter specific).
  return 0xF8 | m_status;
}

//------------------------------------------------------------------------------

void Ym2413::YM2413Update(int* buffer, int length)
{
  int i, out;

  for (i = 0; i < length; i++) {
    m_output[0] = 0;
    m_output[1] = 0;

    advance_lfo();

    // FM part.
    chan_calc(&m_P_CH[0]);
    chan_calc(&m_P_CH[1]);
    chan_calc(&m_P_CH[2]);
    chan_calc(&m_P_CH[3]);
    chan_calc(&m_P_CH[4]);
    chan_calc(&m_P_CH[5]);

    if (!(m_rhythm & 0x20)) {
      chan_calc(&m_P_CH[6]);
      chan_calc(&m_P_CH[7]);
      chan_calc(&m_P_CH[8]);
    } else    // Rhythm part.
    {
      rhythm_calc(&m_P_CH[0], (m_noise_rng >> 0) & 1);
    }

    // Melody (MO) & Rythm (RO) outputs mixing & amplification (latched bit controls FM output).
    out = (m_output[0] + (m_output[1] * 2)) * 2 * m_status;

    // Store to stereo sound buffer.
    *buffer++ = out;
    *buffer++ = out;

    advance();
  }
}

//------------------------------------------------------------------------------

void Ym2413::ClearContext()
{
  xee::mem::Memset(&m_P_CH, 0, sizeof(m_P_CH));
  xee::mem::Memset(&m_instvol_r, 0, sizeof(m_instvol_r));
  m_eg_cnt = 0;
  m_eg_timer = 0;
  m_eg_timer_add = 0;
  m_eg_timer_overflow = 0;
  m_rhythm = 0;

  m_lfo_am_cnt = 0;
  m_lfo_am_inc = 0;
  m_lfo_pm_cnt = 0;
  m_lfo_pm_inc = 0;

  m_noise_rng = 0;
  m_noise_p = 0;
  m_noise_f = 0;

  xee::mem::Memset(&m_inst_tab, 0, sizeof(m_inst_tab));
  xee::mem::Memset(&m_fn_tab, 0, sizeof(m_fn_tab));

  m_address = 0;
  m_status = 0;
  m_clock = 0.0f;
  m_rate = 0;

}

//------------------------------------------------------------------------------

int Ym2413::LoadContext(unsigned char* state)
{
  int bufferptr = 0;

  load_param(&m_P_CH, sizeof(m_P_CH));
  load_param(&m_instvol_r, sizeof(m_instvol_r));

  load_param(&m_eg_cnt, sizeof(m_eg_cnt));
  load_param(&m_eg_timer, sizeof(m_eg_timer));
  load_param(&m_eg_timer_add, sizeof(m_eg_timer_add));
  load_param(&m_eg_timer_overflow, sizeof(m_eg_timer_overflow));

  load_param(&m_rhythm, sizeof(m_rhythm));

  load_param(&m_lfo_am_cnt, sizeof(m_lfo_am_cnt));
  load_param(&m_lfo_am_inc, sizeof(m_lfo_am_inc));
  load_param(&m_lfo_pm_cnt, sizeof(m_lfo_pm_cnt));
  load_param(&m_lfo_pm_inc, sizeof(m_lfo_pm_inc));

  load_param(&m_noise_rng, sizeof(m_noise_rng));
  load_param(&m_noise_p, sizeof(m_noise_p));
  load_param(&m_noise_f, sizeof(m_noise_f));

  load_param(&m_inst_tab, sizeof(m_inst_tab));

  load_param(&m_fn_tab, sizeof(m_fn_tab));

  load_param(&m_address, sizeof(m_address));
  load_param(&m_status, sizeof(m_status));

  load_param(&m_clock, sizeof(m_clock));
  load_param(&m_rate, sizeof(m_rate));

  return bufferptr;
}

//------------------------------------------------------------------------------

int Ym2413::SaveContext(unsigned char* state)
{
  int bufferptr = 0;

  save_param(&m_P_CH, sizeof(m_P_CH));
  save_param(&m_instvol_r, sizeof(m_instvol_r));

  save_param(&m_eg_cnt, sizeof(m_eg_cnt));
  save_param(&m_eg_timer, sizeof(m_eg_timer));
  save_param(&m_eg_timer_add, sizeof(m_eg_timer_add));
  save_param(&m_eg_timer_overflow, sizeof(m_eg_timer_overflow));

  save_param(&m_rhythm, sizeof(m_rhythm));

  save_param(&m_lfo_am_cnt, sizeof(m_lfo_am_cnt));
  save_param(&m_lfo_am_inc, sizeof(m_lfo_am_inc));
  save_param(&m_lfo_pm_cnt, sizeof(m_lfo_pm_cnt));
  save_param(&m_lfo_pm_inc, sizeof(m_lfo_pm_inc));

  save_param(&m_noise_rng, sizeof(m_noise_rng));
  save_param(&m_noise_p, sizeof(m_noise_p));
  save_param(&m_noise_f, sizeof(m_noise_f));

  save_param(&m_inst_tab, sizeof(m_inst_tab));

  save_param(&m_fn_tab, sizeof(m_fn_tab));

  save_param(&m_address, sizeof(m_address));
  save_param(&m_status, sizeof(m_status));

  save_param(&m_clock, sizeof(m_clock));
  save_param(&m_rate, sizeof(m_rate));

  return bufferptr;
}

} // namespace gpgx::sound::ym2413

